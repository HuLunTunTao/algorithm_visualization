# 二分查找算法

## 1. 概念介绍和定义
二分查找是一种在有序数据中快速定位目标位置的算法。它每次选取当前区间的中点与目标比较，根据大小关系将搜索范围缩小到一半，如此迭代直到找到目标或区间为空。由于每一步都将问题规模减半，其时间复杂度为 O(log n)，典型实现只需常量级额外空间。

使用前提是“可比较且单调”的数据结构：最常见是升序或降序数组，也可以是答案具有单调性的判定函数（例如某条件从“不可行”到“可行”单调变化），此时二分的是答案空间而非数组元素。

适用场景包括：
- 在大规模有序/列表中查找某个值或判断是否存在
- 处理重复元素时寻找第一个、最后一个出现的位置，或计算元素出现的区间
- 需要插入一个值并保持有序时，确定插入位置
- 在“满足条件的最小值/最大值”这类单调优化问题中定位边界（如最小可行容量、最大阈值）

二分查找的目标是用尽可能少的比较完成定位与判定：
- 以对数级步数找到目标元素的索引或报告不存在
- 在存在重复的情况下精确锁定边界（lower_bound/upper_bound 的含义）
- 以稳定方式给出插入点，便于维护有序结构
- 将复杂搜索转化为对答案的二分，提高效率与确定性

实现时需正确计算中点、防止溢出与死循环，并明确区间的开闭边界。

## 2. 核心原理解释
二分查找的核心在于：在有序集合上，通过一次比较就能把仍需搜索的区间缩小一半，从而以对数级步数定位目标。为此，算法始终维护一个“仍可能包含目标”的区间，并用中点将其二分。关键是利用有序性与区间不变式：每轮比较后，只保留仍可能包含目标的那一半。

基本流程如下：
1) 初始化左右边界 l=0、r=n-1，采用闭区间[l,r]表示“可行”范围。
2) 取中点 mid = l + (r - l) / 2（防止溢出）。
3) 若 a[mid] 等于目标，返回该位置；若 a[mid] 小于目标，目标只可能在右侧，令 l = mid + 1；若 a[mid] 大于目标，目标只可能在左侧，令 r = mid - 1。
4) 重复上述步骤，直到 l > r 表示区间为空，目标不存在。

举例：在有序数组[1,3,5,7,9,11]中找7。
- 初始 l=0,r=5，mid=2，a[2]=5<7，丢弃左半含mid，l=3。
- 现 l=3,r=5，mid=4，a[4]=9>7，丢弃右半含mid，r=3。
- 现 l=3,r=3，mid=3，a[3]=7，找到目标，3。

要点归纳：
- 不变式：目标若存在，始终位于当前[l,r]内。
- 更新边界时必须排除已判定不含目标的中点，避免死循环。
- 时间复杂度O(log n)，空间复杂度O(1)。
- 若需找第一个/最后一个等于某值的下标，可在等于时继续收缩一侧边界边界型二分。

## 3. 详细的实现步骤
- 步骤与要点：
  1) 保证数组已按非降序排列。
  2) 采用闭区间 [left, right] 表示搜索范围。
  3) 初始化 left=0, right=n-1，循环条件为 left<=right。
  4) 计算中点 mid=left+(right-left)/2，避免加法溢出。
  5) 比较 a[mid] 与 target：相等则返回；若小于则令 left=mid+1；若大于则令 right=mid-1。
  6) 循环结束仍未命中则返回 -1。
- 注意事项：每次收缩必须排除 mid 以防死循环；查找左右边界时，命中后分别令 right=mid-1 或 left=mid+1，并在循环后验证索引是否越界与是否等于目标。时间 O(log n)，空间 O(1)。

```cpp
int binarySearch(const std::vector<int>& a, int target) {
    int left = 0, right = (int)a.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (a[mid] == target) return mid;
        else if (a[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return -1;
}
```

## 4. 完整的C++代码示例（包含注释）

下面给出一个可直接编译运行的 C++17 示例，演示在“有序数组”上使用二分查找，稳定地返回目标值的“首次出现位置”（若不存在则返回 -1）。示例包含：
- 输入：数组长度 n、按非递减顺序输入的 n 个整数、查询次数 q，以及 q 个待查找的目标值
- 输出：每个目标值的查找结果（首次出现的索引，或 -1）
- 详细注释与一个完整的输入/输出示例

```cpp
#include <iostream>
#include <vector>
using namespace std;

/*

## 5. 代码解析和说明

```cpp
#include <vector>
int binary_search(const std::vector<int>& a, int target) {
    int l = 0, r = (int)a.size() - 1;
    while (l <= r) {
        int mid = l + (r - l) / 2;
        if (a[mid] == target) return mid;
        else if (a[mid] < target) l = mid + 1;
        else r = mid - 1;
    }
    return -1;
}
```

- 初始化：区间[l, r]覆盖候选范围；当数组为空时，r = -1，循环不执行，直接返回-1。
- 循环条件：l <= r保证区间非空。mid采用l + (r - l) / 2避免(l + r)溢出。
- 比较与收缩：若命中直接返回；a[mid] < target则目标在右侧，更新l = mid + 1；否则在左侧，更新r = mid - 1。每次迭代至少丢弃一半元素，确保收敛与终止。

复杂度分析：
- 时间复杂度O(log n)，因每次区间折半；空间复杂度O(1)，只用常数额外变量。

边界与变体：
- 适用于空数组、单元素、目标在两端、目标不存在等情况。
- 重复元素：若需最左位置，可在等于时记录答案并令r = mid - 1；最右位置则令l = mid + 1。
- 前提是数组有序（升序）。若为降序，需反转比较方向。
- 避免死循环与越界的关键在于更新为mid ± 1，并坚持闭区间[l, r]语义。

## 6. 使用场景和应用
二分查找适用于有序或单调空间的快速定位。常见应用：
- 静态有序数组中的精确查找与去重统计，利用 lower_bound/upper_bound 定位第一个≥x、最后一个≤x。
- 单调判定/答案二分：如最小可行容量、最短完成时间、阈值定位。
- 数值逼近：对单调连续函数做区间逼近求根（如二分法）。
- 业务示例：时间戳日志定位、区间映射（IP段归属）、排行榜名次定位。

优势：
- 时间复杂度 O(log n)、实现简洁、额外空间 O(1)。
- 能稳定扩展为区间计数、插入位置计算、范围查询的边界定位。

局限：
- 需数据有序或判定函数单调；数据频繁变动时维护排序成本高。
- 易出边界/溢出/死循环等实现陷阱；跳跃访问导致缓存与分支预测不友好，小规模时线性扫描更快。

替代方案：
- 哈希表：平均 O(1) 精确查找，缺乏顺序与范围语义。
- 平衡树/跳表：O(log n) 且支持动态插入删除与顺序统计。
- B-树族：面向外存索引更高效。
- 插值查找：分布均匀时期望更快。
- 指数查找配合二分：上界未知场景先扩展再定位。

## 7. 注意事项和最佳实践
- 常见坑
  - 中点溢出：用 mid = l + (r - l) / 2，避免 (l + r) 溢出。
  - 死循环与越界：更新边界要严格排除 mid，例如目标在右半区时 l = mid + 1；在左半区时 r = mid - 1。用 [l, r] 或 [l, r) 区间时保持始终如一。
  - 条件选择：查存在常用 while (l <= r)，找插入位/第一个满足条件则常用 while (l < r) 的半开区间写法。
  - 重复值处理：明确需求（任意位置/首个/最后一个），对应实现 lower_bound/upper_bound，避免返回错误边界。
  - 先决条件：数据必须按与比较函数一致的顺序有序；索引尽量用有符号整型，避免无符号借位问题。
- 优化建议
  - 优先使用标准库：std::lower_bound / std::upper_bound，正确、快且经过优化。
  - 统一模板：采用半开区间 [l, r) 可减少边界分支；必要时返回插入位置，便于后续插入或去重。
  - 避免递归版造成栈开销；热路径中可减少分支或启用 -O2/-O3。
  - 大数据上注意缓存局部性，尽量顺序访问；比较函数应为纯函数、无副作用。
- 参考实现（lower_bound 模式，返回第一个 >= x 的位置）
```cpp
#include <vector>
using namespace std;

size_t lower_bound_idx(const vector<int>& a, int x) {
    size_t l = 0, r = a.size(); // 区间为 [l, r)
    while (l < r) {
        size_t m = l + (r - l) / 2;
        if (a[m] < x) l = m + 1;
        else r = m;
    }
    return l; // 可能等于 a.size()
}
```
- 测试要点
  - 空数组、单元素、全相等、严格递增、含重复。
  - 命中首位/末位/中间、未命中且应返回插入位。
  - 极值：INT_MIN/INT_MAX、超大数组验证性能与溢出。
  - 自定义比较/降序数组（或验证失败场景）。
  - 随机回归与边界压力测试，确保无死循环与越界。

## 8. 相关知识点与延伸阅读
- 相关概念
  - 单调性与判定函数（check）；不变量与边界收缩策略（开闭区间、左闭右开）；越界与死循环防护
  - 上/下界、首/末个满足；浮点二分与精度控制；离散化与去重
  - 标准库：std::lower_bound/upper_bound/equal_range；指数搜索、插值查找对比
- 进阶方向
  - 答案二分（最大化最小值、最小化最大值），二分结合贪心/前缀和/并查集/最短路等作为check
  - 复杂场景：旋转有序数组、重复区间、二维矩阵、单调函数图像
  - 多关键字二分；三分/黄金分割用于单峰函数；参数搜索与分治优化
- 参考资料
  - CLRS《算法导论》二分查找与排序相关章节
  - cp-algorithms: Binary Search 与 Ternary Search 专题
  - C++ reference: lower_bound/upper_bound/equal_range 文档
  - LeetCode 704/34/153 题与题单；《算法竞赛进阶指南》答案二分章节
