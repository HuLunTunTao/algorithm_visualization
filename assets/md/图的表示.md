# 图的表示

## 1. 概念介绍和定义

图（Graph）是一种非常重要的数据结构，用于表示对象之间的关系。它由两个基本元素组成：顶点（Vertex）和边（Edge）。顶点代表对象，边则代表对象之间的连接关系。例如，在社交网络中，每个人可以看作一个顶点，而好友关系则可以表示为边。

图的表示方法有多种，每种方法都有其适用的场景和目标。常见的表示方法包括邻接矩阵和邻接表。选择哪种表示方法通常取决于图的具体特性（如稀疏或稠密）以及需要执行的操作（如频繁的查询或遍历）。

适用场景：
- 邻接矩阵适合表示稠密图（边数接近顶点数的平方），并且需要快速判断两个顶点是否相邻的场景。
- 邻接表适合表示稀疏图（边数远小于顶点数的平方），并且需要高效遍历邻接顶点或节省存储空间的场景。

目标：
- 高效地存储图结构，减少内存占用。
- 支持常见的图操作，如添加/删除顶点或边、查询邻接关系、遍历图等。

下面是一个简单的图结构示例，使用C++的邻接表表示：

```cpp
#include <iostream>
#include <vector>
using namespace std;

class Graph {
private:
    int numVertices;
    vector<vector<int>> adjList;

public:
    Graph(int vertices) : numVertices(vertices), adjList(vertices) {}

    void addEdge(int src, int dest) {
        adjList[src].push_back(dest);
        adjList[dest].push_back(src); // 无向图需要双向添加
    }

    void printGraph() {
        for (int i = 0; i < numVertices; i++) {
            cout << "顶点 " << i << " 的邻接顶点：";
            for (int neighbor : adjList[i]) {
                cout << neighbor << " ";
            }
            cout << endl;
        }
    }
};

int main() {
    Graph g(5);
    g.addEdge(0, 1);
    g.addEdge(0, 4);
    g.addEdge(1, 2);
    g.addEdge(1, 3);
    g.addEdge(1, 4);
    g.addEdge(2, 3);
    g.addEdge(3, 4);
    g.printGraph();
    return 0;
}
```

通过这个示例，你可以初步了解如何使用邻接表来构建和表示一个无向图。

## 2. 核心原理解释

图的表示方法主要分为两种：邻接矩阵和邻接表。它们各有优缺点，适用于不同的场景。下面我们来详细解析这两种表示方法的核心原理。

### 邻接矩阵表示法

邻接矩阵使用二维数组来表示图中顶点之间的连接关系。假设图有n个顶点，我们就创建一个n×n的矩阵。矩阵中的每个元素表示对应顶点之间是否存在边（对于无权图）或者边的权重（对于带权图）。

关键特点：
- 矩阵的行和列都代表图中的顶点
- 对于无向图，矩阵是对称的
- 对于有向图，矩阵不一定对称
- 对角线元素通常为0（顶点到自身的距离）

示例：一个有4个顶点的无向图
```
顶点：0,1,2,3
边：(0,1), (0,2), (1,3), (2,3)

邻接矩阵：
   0  1  2  3
0  0  1  1  0
1  1  0  0  1  
2  1  0  0  1
3  0  1  1  0
```

```cpp
// 邻接矩阵的C++实现
#include <vector>
using namespace std;

class Graph {
private:
    int V; // 顶点数
    vector<vector<int>> adjMatrix;
    
public:
    Graph(int vertices) : V(vertices) {
        adjMatrix.resize(V, vector<int>(V, 0));
    }
    
    void addEdge(int u, int v) {
        adjMatrix[u][v] = 1;
        adjMatrix[v][u] = 1; // 对于无向图
    }
    
    bool isConnected(int u, int v) {
        return adjMatrix[u][v] == 1;
    }
};
```

### 邻接表表示法

邻接表为每个顶点维护一个链表，链表中存储与该顶点直接相连的所有顶点。这种方法更节省空间，特别适用于稀疏图（边数远少于顶点数平方的图）。

关键特点：
- 每个顶点对应一个链表
- 链表中的节点表示与该顶点相连的邻接顶点
- 可以轻松获取某个顶点的所有邻居
- 空间复杂度为O(V+E)，比邻接矩阵更高效

```cpp
// 邻接表的C++实现
#include <vector>
#include <list>
using namespace std;

class Graph {
private:
    int V; // 顶点数
    vector<list<int>> adjList;
    
public:
    Graph(int vertices) : V(vertices) {
        adjList.resize(V);
    }
    
    void addEdge(int u, int v) {
        adjList[u].push_back(v);
        adjList[v].push_back(u); // 对于无向图
    }
    
    list<int> getNeighbors(int u) {
        return adjList[u];
    }
};
```

### 选择建议

在实际应用中，选择哪种表示方法取决于具体需求：
- 邻接矩阵适合稠密图，需要频繁判断顶点间是否相连
- 邻接表适合稀疏图，需要频繁遍历某个顶点的所有邻居
- 邻接矩阵的查询时间复杂度为O(1)，而邻接表为O(degree(v))
- 邻接表的空间效率通常更高

## 3. 详细的实现步骤

图的表示方法主要有两种：邻接矩阵和邻接表。下面分别介绍它们的实现步骤。

### 邻接矩阵实现步骤
1. **确定图的顶点数量**：假设图有n个顶点，通常用整数0到n-1进行编号
2. **创建二维数组**：构建一个n×n的二维数组matrix，初始化为0
3. **填充矩阵元素**：
   - 对于无向图：如果顶点i和j之间有边，则设置matrix[i][j]和matrix[j][i]为1（或权重值）
   - 对于有向图：如果存在从i到j的边，则设置matrix[i][j]为1（或权重值）
4. **处理自环边**：如果允许自环，对角线元素可能为非零值

```cpp
#include <vector>
using namespace std;

class GraphMatrix {
private:
    int numVertices;
    vector<vector<int>> matrix;
    
public:
    GraphMatrix(int n) : numVertices(n), matrix(n, vector<int>(n, 0)) {}
    
    void addEdge(int i, int j, int weight = 1) {
        matrix[i][j] = weight;
        matrix[j][i] = weight; // 对于无向图
    }
    
    void removeEdge(int i, int j) {
        matrix[i][j] = 0;
        matrix[j][i] = 0; // 对于无向图
    }
    
    bool isEdge(int i, int j) {
        return matrix[i][j] != 0;
    }
};
```

### 邻接表实现步骤
1. **创建顶点列表**：为每个顶点创建一个链表或动态数组
2. **构建邻接关系**：
   - 对于每个顶点，存储其所有邻接顶点的信息
   - 可以同时存储边的权重信息
3. **选择存储结构**：
   - 使用vector<vector<pair<int, int>>>：适用于需要频繁遍历的场景
   - 使用链表数组：适用于频繁增删边的场景

```cpp
#include <vector>
#include <list>
#include <utility>
using namespace std;

class GraphList {
private:
    int numVertices;
    vector<list<pair<int, int>>> adjList; // pair<邻接顶点, 权重>
    
public:
    GraphList(int n) : numVertices(n), adjList(n) {}
    
    void addEdge(int src, int dest, int weight = 1) {
        adjList[src].push_back(make_pair(dest, weight));
        adjList[dest].push_back(make_pair(src, weight)); // 对于无向图
    }
    
    void removeEdge(int src, int dest) {
        // 需要遍历链表找到对应边并删除
        for(auto it = adjList[src].begin(); it != adjList[src].end(); ++it) {
            if(it->first == dest) {
                adjList[src].erase(it);
                break;
            }
        }
        // 对于无向图，还需要删除反向边
    }
};
```

**实现要点**：
- 邻接矩阵适合稠密图，查询速度快但空间复杂度高
- 邻接表适合稀疏图，空间效率高但查询稍慢
- 根据具体应用场景选择合适的表示方法
- 注意处理有向图和无向图的区别

## 4. 完整的C++代码示例（包含注释）

以下是一个使用C++17标准编写的图的邻接矩阵和邻接表表示示例。代码包含完整的main函数，可以直接编译运行。

```cpp
#include <iostream>
#include <vector>
#include <memory>

using namespace std;

// 图的邻接矩阵表示类
class GraphMatrix {
private:
    int numVertices;          // 顶点数量
    vector<vector<int>> adjMatrix; // 邻接矩阵

public:
    // 构造函数，初始化顶点数量和邻接矩阵
    GraphMatrix(int n) : numVertices(n), adjMatrix(n, vector<int>(n, 0)) {}
    
    // 添加边（无向图）
    void addEdge(int i, int j) {
        if (i >= 0 && i < numVertices && j >= 0 && j < numVertices) {
            adjMatrix[i][j] = 1;
            adjMatrix[j][i] = 1; // 无向图需要对称设置
        }
    }
    
    // 打印邻接矩阵
    void printMatrix() {
        cout << "邻接矩阵表示：" << endl;
        for (int i = 0; i < numVertices; i++) {
            for (int j = 0; j < numVertices; j++) {
                cout << adjMatrix[i][j] << " ";
            }
            cout << endl;
        }
    }
};

// 图的邻接表表示类
class GraphList {
private:
    int numVertices;          // 顶点数量
    vector<vector<int>> adjList; // 邻接表

public:
    // 构造函数，初始化顶点数量和邻接表
    GraphList(int n) : numVertices(n), adjList(n) {}
    
    // 添加边（无向图）
    void addEdge(int i, int j) {
        if (i >= 0 && i < numVertices && j >= 0 && j < numVertices) {
            adjList[i].push_back(j);
            adjList[j].push_back(i); // 无向图需要双向添加
        }
    }
    
    // 打印邻接表
    void printList() {
        cout << "邻接表表示：" << endl;
        for (int i = 0; i < numVertices; i++) {
            cout << "顶点 " << i << " 连接至：";
            for (const auto& neighbor : adjList[i]) {
                cout << neighbor << " ";
            }
            cout << endl;
        }
    }
};

int main() {
    // 创建一个包含5个顶点的图
    const int VERTEX_COUNT = 5;
    
    // 使用邻接矩阵表示图
    GraphMatrix matrixGraph(VERTEX_COUNT);
    matrixGraph.addEdge(0, 1);
    matrixGraph.addEdge(0, 4);
    matrixGraph.addEdge(1, 2);
    matrixGraph.addEdge(1, 3);
    matrixGraph.addEdge(1, 4);
    matrixGraph.addEdge(2, 3);
    matrixGraph.addEdge(3, 4);
    
    // 使用邻接表表示相同的图
    GraphList listGraph(VERTEX_COUNT);
    listGraph.addEdge(0, 1);
    listGraph.addEdge(0, 4);
    listGraph.addEdge(1, 2);
    listGraph.addEdge(1, 3);
    listGraph.addEdge(1, 4);
    listGraph.addEdge(2, 3);
    listGraph.addEdge(3, 4);
    
    // 输出两种表示方式的结果
    cout << "=== 图的两种表示方法示例 ===" << endl;
    matrixGraph.printMatrix();
    cout << endl;
    listGraph.printList();
    
    return 0;
}
```

编译运行此代码将输出：
```
=== 图的两种表示方法示例 ===
邻接矩阵表示：
0 1 0 0 1 
1 0 1 1 1 
0 1 0 1 0 
0 1 1 0 1 
1 1 0 1 0 

邻接表表示：
顶点 0 连接至：1 4 
顶点 1 连接至：0 2 3 4 
顶点 2 连接至：1 3 
顶点 3 连接至：1 2 4 
顶点 4 连接至：0 1 3 
```

代码说明：
- 本示例展示了图的两种基本表示方法：邻接矩阵和邻接表
- GraphMatrix类使用二维vector实现邻接矩阵
- GraphList类使用vector的vector实现邻接表
- main函数中创建了一个包含5个顶点的无向图，并添加了7条边
- 程序会分别输出邻接矩阵和邻接表的表示结果

## 5. 代码解析和说明

以下是用C++实现的邻接矩阵表示图的代码示例：

```cpp
#include <iostream>
#include <vector>
using namespace std;

class Graph {
private:
    int V; // 顶点数
    vector<vector<int>> adjMatrix; // 邻接矩阵

public:
    Graph(int vertices) : V(vertices) {
        adjMatrix.resize(V, vector<int>(V, 0));
    }

    void addEdge(int u, int v) {
        if (u >= 0 && u < V && v >= 0 && v < V) {
            adjMatrix[u][v] = 1;
            adjMatrix[v][u] = 1; // 无向图需要对称设置
        }
    }

    void printGraph() {
        for (int i = 0; i < V; i++) {
            for (int j = 0; j < V; j++) {
                cout << adjMatrix[i][j] << " ";
            }
            cout << endl;
        }
    }
};
```

**代码解析：**
- 构造函数 `Graph(int vertices)` 初始化顶点数并创建V×V的二维矩阵，所有元素初始化为0
- `addEdge(int u, int v)` 方法在顶点u和v之间添加边，对于无向图需要同时设置adjMatrix[u][v]和adjMatrix[v][u]
- `printGraph()` 方法按行打印邻接矩阵，直观展示图的连接关系

**复杂度分析：**
- 空间复杂度：O(V²)，需要存储V×V的矩阵
- 添加边的时间复杂度：O(1)，直接通过索引访问和修改矩阵元素
- 打印图的时间复杂度：O(V²)，需要遍历整个矩阵

**边界情况处理：**
- 在addEdge方法中检查顶点索引是否有效（0 ≤ u,v < V）
- 构造函数需要处理顶点数为0或负数的情况（示例中未展示，实际应用中应添加异常处理）
- 对于有向图，只需要设置adjMatrix[u][v] = 1，不需要对称设置
- 带权图可将矩阵元素类型改为int或float，存储权重值而非简单的0/1

## 6. 使用场景和应用

图的表示方法在实际应用中具有广泛的使用场景，每种表示法都有其独特的优势和适用条件。理解不同表示法的特点，有助于在实际开发中选择最合适的方案。

### 常见应用场景
- **邻接矩阵**：适用于稠密图或需要频繁判断顶点间是否存在边的场景，如路由算法、图的连通性判断
- **邻接表**：适用于稀疏图或需要遍历邻接节点的场景，如社交网络、网页链接分析
- **关联矩阵**：适用于超图或需要表示顶点与边关系的特殊场景，如电路分析、 Petri网

### 优劣比较
**邻接矩阵优势**：
- 判断任意两顶点是否相邻的时间复杂度为O(1)
- 易于实现图的操作和算法

**邻接矩阵劣势**：
- 空间复杂度为O(V²)，不适合稀疏图
- 添加/删除顶点时代价较高

**邻接表优势**：
- 空间复杂度为O(V+E)，适合稀疏图
- 可以快速遍历某个顶点的所有邻接点

**邻接表劣势**：
- 判断两顶点是否相邻需要遍历链表，时间复杂度为O(V)
- 实现相对复杂

### 替代方案比较
在实际开发中，除了基本的邻接矩阵和邻接表，还可以考虑以下优化方案：

- **邻接集合**：使用哈希集合代替链表存储邻接节点，提高查询效率
```cpp
#include <unordered_set>
#include <vector>
using namespace std;

class Graph {
private:
    vector<unordered_set<int>> adjSet;
    
public:
    Graph(int vertices) : adjSet(vertices) {}
    
    void addEdge(int u, int v) {
        adjSet[u].insert(v);
        adjSet[v].insert(u); // 无向图
    }
    
    bool isAdjacent(int u, int v) {
        return adjSet[u].find(v) != adjSet[u].end();
    }
};
```

- **压缩稀疏行（CSR）**：适用于大规模稀疏图，节省内存空间
- **邻接字典**：适用于需要存储边权重的场景，使用字典存储边信息

选择何种表示方法应根据具体应用需求、图的大小和稀疏程度、以及需要频繁执行的操作类型来决定。

## 7. 注意事项和最佳实践

在图的表示和实现过程中，需要注意以下几个关键点，以确保代码的正确性和高效性。

### 常见坑
- **索引混淆**：图的顶点通常从0或1开始编号，但在代码实现时容易混淆，导致数组越界或逻辑错误。
- **内存管理**：对于邻接矩阵或动态分配的邻接表，忘记释放内存会导致内存泄漏。
- **重复边处理**：在无向图中，添加边(u, v)和(v, u)可能导致重复，需根据实际需求处理。
- **权重类型**：带权图中，权重可能是整数、浮点数或其他类型，需统一处理以避免类型错误。

### 优化建议
- **空间优化**：对于稀疏图，优先使用邻接表以节省内存；对于稠密图，邻接矩阵更合适。
- **缓存友好**：访问邻接矩阵时，尽量按行访问以提高缓存命中率。
- **使用STL容器**：在C++中，优先使用`vector`和`list`来实现邻接表，避免手动管理内存。
- **预分配空间**：如果已知图的规模，提前分配足够空间以避免频繁扩容。

### 测试要点
- **基本功能测试**：验证添加顶点和边的正确性，确保图的结构符合预期。
- **遍历测试**：对DFS和BFS进行测试，检查遍历顺序是否正确。
- **性能测试**：针对大规模图测试内存占用和时间效率，确保符合应用需求。
- **边界测试**：测试空图、单顶点图、完全图等边界情况。

以下是一个邻接表实现的示例代码，展示了如何避免常见错误：

```cpp
#include <vector>
#include <list>
#include <iostream>

using namespace std;

class Graph {
private:
    int V;
    vector<list<int>> adj;

public:
    Graph(int V) : V(V), adj(V) {}

    void addEdge(int u, int v) {
        if (u < 0 || u >= V || v < 0 || v >= V) {
            cerr << "Invalid vertex index!" << endl;
            return;
        }
        adj[u].push_back(v);
        // For undirected graph, uncomment the next line
        // adj[v].push_back(u);
    }

    void printGraph() {
        for (int i = 0; i < V; ++i) {
            cout << i << ": ";
            for (int neighbor : adj[i]) {
                cout << neighbor << " ";
            }
            cout << endl;
        }
    }
};

int main() {
    Graph g(5);
    g.addEdge(0, 1);
    g.addEdge(0, 4);
    g.addEdge(1, 2);
    g.addEdge(1, 3);
    g.addEdge(1, 4);
    g.addEdge(2, 3);
    g.addEdge(3, 4);
    g.printGraph();
    return 0;
}
```

通过遵循上述注意事项和最佳实践，你可以更可靠地实现和应用图的表示方法。

## 8. 相关知识点与延伸阅读

### 相关概念
- **邻接多重表**：适用于无向图的高效存储结构，每条边只存储一次，避免邻接表的冗余
- **十字链表**：专门为有向图设计的链式存储结构，同时包含入边和出边信息
- **图数据库**：基于图结构的数据库系统（如Neo4j），使用节点和关系存储数据

### 进阶方向
1. **动态图算法**：研究图结构随时间变化的处理算法
2. **并行图计算**：使用多线程或分布式系统处理大规模图数据
3. **图神经网络**：将深度学习与图结构相结合的新兴领域
4. **图嵌入**：将图节点映射到低维向量空间的技术

### 参考资料
- 教材推荐：
  - 《算法导论》图算法章节
  - 《数据结构与算法分析》图表示相关章节
- 在线资源：
  - GeeksforGeeks图数据结构专题
  - VisualGo图可视化学习平台
- 学术论文：
  - "The Anatomy of a Large-Scale Hypertextual Web Search Engine"（Google PageRank原始论文）
  - "Graph Neural Networks: A Review of Methods and Applications"（图神经网络综述）

```cpp
// 邻接多重表边节点结构示例
struct EdgeNode {
    int ivex, jvex;              // 边的两个顶点
    EdgeNode* ilink,* jlink;     // 分别指向ivex和jvex的下一条边
    int weight;                  // 边权（可选）
};
```
