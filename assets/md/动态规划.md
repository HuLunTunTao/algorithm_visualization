# 动态规划

## 1. 概念介绍和定义
动态规划（Dynamic Programming，简称 DP）是一种将复杂问题分解为相互重叠的子问题、并通过复用子问题解来降低总体计算量的系统化方法。它的核心思想是“分阶段做决策”，利用子问题的最优解构成整体最优解（最优子结构），并通过缓存/表格避免重复计算（重叠子问题）。

关键要素通常包括：
- 状态：用若干变量刻画到当前为止的关键信息。
- 决策：在某个状态下可以采取的选择。
- 状态转移：旧状态如何通过决策得到新状态的关系（转移方程/递推式）。
- 边界条件：起点或最小子问题的已知结果。
- 目标：求最值、计数、可行性或方案数等。

典型适用场景：
- 子问题会重复出现，且存在最优子结构。
- 状态可枚举且有限，转移依赖局部历史而非完整路径。
- 需要全局最优或统计结果的问题，如爬楼梯、背包、编辑距离、区间动态、股票买卖等。

DP 的目标是把原本指数级的暴力搜索转化为多项式复杂度：明确状态定义与转移方程，利用记忆化搜索（自顶向下）或表格法（自底向上）求解，并在可能时进行空间优化（如滚动数组），最终获得可解释、可验证的最优结果。

## 2. 核心原理解释
动态规划的核心是以空间换时间：把原问题分解为一系列相互关联、存在重叠子问题的阶段，通过保存阶段最优解避免重复计算。它依赖两大性质：
- 最优子结构：整体最优解可由若干子问题的最优解组合而成。
- 重叠子问题：同一子问题会被多次访问，适合缓存或表格化。

落地的关键步骤是：
1) 定义状态：明确 dp[i] 或 dp[i][j] 的含义（指标、维度、约束）。
2) 写出转移：找出 dp 与更小状态之间的关系。
3) 设定边界：给出初值/非法值，保证递推起点正确。
4) 确定顺序：自顶向下（记忆化）或自底向上（表格法），确保用到的子状态已被计算。
5) 优化空间：若转移只依赖有限前置状态，可用滚动数组/变量压缩内存。

示例（斐波那契）：令 dp[i] 表示第 i 项，转移 dp[i] = dp[i−1] + dp[i−2]，边界 dp[0]=0, dp[1]=1。自底向上能线性时间求解，并可进一步用两个滚动变量将空间降为 O(1)。

```cpp
#include <vector>
int fib(int n) {
    if (n == 0) return 0;
    if (n == 1) return 1;
    std::vector<long long> dp(n + 1);
    dp[0] = 0;
    dp[1] = 1;
    for (int i = 2; i n; ++i) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return (int)dp[n];
}
```

## 3. 详细的实现步骤
1) 明确子问题与目标：识别最优子结构与子问题边界，确定最终要返回的量。  
2) 定义状态 dp：确定维度与含义，如 dp[i]、dp[i][j] 等，确保能覆盖所有子问题。  
3) 推导转移方程：基于“选择/切分”写出 dp 的依赖关系，保证无后效性与子问题不重叠。  
4) 设定初始值：列出所有边界情形（如空集、0/1 长度），给出确定值。  
5) 确定计算顺序：按依赖拓扑遍历（如一维从小到大、二维按行/列或拓扑序）。  
6) 代码实现：分配并初始化 dp，按顺序填表，返回答案所在位置（如 dp[n] 或 dp[n][m]）。  
7) 优化与校验：若仅依赖近邻，用滚动数组/常量变量降维；用小样例断言正确；需重建方案时额外记录 choice 并回溯。

示例（爬楼梯，dp[i]=到第 i 阶的方法数）：
```cpp
int climbStairs(int n){
    if(n<=0) return 0;
    if(n<=2) return n;
    int a=1,b=2;
    for(int i=3;i<=n;i++){
        int c=a+b;
        a=b; b=c;
    }
    return b;
}
```

## 4. 完整的C++代码示例（包含注释）

下面的示例用“0/1 背包问题”演示动态规划的典型思路。程序同时实现：
- 二维 DP（便于讲解和路径回溯，输出选取的物品）
- 一维滚动数组优化（节省空间）

输入格式：
- 第一行：n W（物品个数与背包容量）
- 第二行：n 个整数，表示每个物品的重量
- 第三行：n 个整数，表示每个物品的价值

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

using namespace std;

/*
目标问题：0/1 背包
- 给定 n 个物品，每个物品有重量 w[i] 和价值 v[i]，每个物品最多选一次。
- 背包容量为 W，求能够获得的最大价值，并恢复一个可行的选取方案。

状态设计（二维 DP，便于回溯）：
- dp[i][cap] 表示使用前 i 个物品（下标 1..i），在容量为 cap 时可获得的最大价值。

## 5. 代码解析和说明
```cpp
#include <bits/stdc++.h>
using namespace std;

int knap01(int W, const vector<int>& wt, const vector<int>& val){
    int n = wt.size();
    vector<int> dp(W + 1, 0);
    for(int i = 0; i < n; ++i){
        for(int w = W; w >= wt[i]; --w){
            dp[w] = max(dp[w], dp[w - wt[i]] + val[i]);
        }
    }
    return dp[W];
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, W;
    if(!(cin >> n >> W)) return 0;
    vector<int> wt(n), val(n);
    for(int i = 0; i < n; ++i) cin >> wt[i] >> val[i];
    cout << knap01(W, wt, val) << "\n";
    return 0;
}
```
本例实现0/1背包的一维DP。dp[w] 表示容量为 w 时的最大价值；初始化为0等价于“容量为0或未选任何物品时价值为0”，dp[0] 也自然为0。外层遍历物品 i，内层 w 从 W 递减到 wt[i]：逆序是关键，防止同一物品在同一轮被多次选取；条件 w >= wt[i] 保证不会访问负下标。转移 dp[w] = max(dp[w], dp[w - wt[i]] + val[i])，在“不选/选该物品”中取优。返回 dp[W] 为最优解。时间复杂度 O(nW)，空间 O(W)，内存约 4W 字节（int）。边界与鲁棒性：1) 若 W=0 或 n=0，答案为0；2) wt[i] > W 的物品自动跳过；3) 默认重量与价值为非负整数，若可能溢出请用 long long；4) 输入失败时主程序早退；5) 当 W 极大时可考虑按价值转状态、分块或近似缩放以控时空成本。

## 6. 使用场景和应用
动态规划适用于存在重叠子问题、最优子结构、有限状态的多阶段决策问题。常见应用包括：
- 序列问题：LIS、LCS、编辑距离、序列对齐
- 背包与资源分配：0/1、完全、多维、多重背包
- 区间与划分：矩阵链乘、石子合并、区间DP、分段最小代价
- 路径规划：网格路径计数/最短路、DAG最短路
- 树与图：树形DP、状压DP
- 其他：数位DP、概率/期望DP、股票买卖、多机调度

优缺点与工程取舍：
- 优点：系统化求最优解；可证明正确；可结合优化（滚动数组、状态压缩、单调队列、斜率优化）降时空复杂度。
- 缺点：状态与转移设计门槛高；维度爆炸与内存占用大；实现细节多、易出错；对数据规模敏感。

替代方案与比较：
- 贪心：满足贪心选择与可交换性时（如区间调度、哈夫曼、最小生成树）更快更简单；但适用面窄，易失最优。
- 分治/记忆化搜索：表达清晰、易剪枝，本质等价DP；常数大，可能栈深问题。
- 图算法：Dijkstra/Bellman-Ford/Floyd 处理一般图最短路；DAG可拓扑+DP线性解决，更高效。
- 线性/整数规划：背包、资源分配可建模为LP/ILP，精确或近似强，但求解器依赖与工程成本高。
- 搜索与启发式：回溯+剪枝、A*、分支定界适合复杂约束；可能仅近似或期望最优，时间不稳定。
- 近似/随机算法：当DP状态巨大时的务实之选（贪心近似、采样、模拟退火）。

经验法则：能清晰定义状态与转移，且“状态数×转移代价”可控时优先DP；否则先简化建模或改用以上替代策略。

## 7. 注意事项和最佳实践
- 常见坑：
  - 状态定义不清或维度滥用，导致转移无从下手或复杂度爆炸。
  - 初始化错误：可达与不可达、极大极小值设置不当；记忆化未赋初值或沿用脏数据。
  - 遍历方向错：0-1 背包应倒序，完全背包顺序；区间DP按区间长度扩展；树形DP需拓扑顺序。
  - 边界与下标：空集、长度为0或1，越界；数组未开够；溢出，int 换 long long；取模产生负值未纠正。
- 优化建议：
  - 状态压缩与滚动数组，谨慎覆盖写入；稀疏状态用 unordered_map 降低空间。
  - 预处理前缀和、单调队列、位运算或倍增以降低转移复杂度。
  - 剪枝与可行性判定，减少无效状态；按依赖顺序遍历，减少条件判断。
  - 统一封装转移与常量（INF、MOD），便于复用与替换，实现更清晰的代码结构。
- 测试要点：
  - 手算小样例核对转移与答案；多组数据重复调用是否重置。
  - 边界与退化：N=0、1，容量或预算为0，值全相等或全负，极限规模与极限值域。
  - 与暴力或高复杂度基准对拍，随机生成覆盖角落用例。
  - 验证路径还原、字典序与稳定性；取模场景多次加减后保持非负。

## 8. 相关知识点与延伸阅读
动态规划与多种算法思想互相渗透，系统化学习有助于拓展解题边界。

- 相关概念
  - 记忆化搜索与自底向上
  - 分治与最优子结构、无后效性
  - 贪心对比DP的适用边界
  - 图论最短路与DP（DAG DP、Bellman-Ford）
  - 搜索+剪枝、状态图建模与拓扑序
- 进阶方向
  - 状态空间建模与转移等价变换
  - 优化：滚动数组、决策单调性与四边形不等式、单调队列/斜率优化
  - 专题：区间DP、树形DP、状态压缩DP、数位DP、概率/期望DP、在线DP
- 参考资料
  - OI-Wiki、CP-Algorithms 的DP条目
  - AtCoder Educational DP Contest（题单+题解）
  - CLRS 与 Algorithm Design（Kleinberg–Tardos）
  - USACO Guide、背包九讲、LeetCode 专题
