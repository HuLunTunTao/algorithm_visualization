# 栈

## 1. 概念介绍和定义
栈（Stack）是一种受限的线性数据结构，只允许在一端进行插入和删除，这一端叫“栈顶”，另一端叫“栈底”。它遵循先进后出（LIFO）的规则：最后压入的元素最先被弹出。常见操作包括：push（压入）、pop（弹出）、top/peek（读取栈顶）、empty/size（判空与计数）。实现上可用动态数组构成“顺序栈”，或用链表构成“链式栈”；在均摊情况下，push/pop 通常为 O(1)。

适用场景：
- 需要“最近的先处理”的过程，如撤销/回退、浏览器前进后退
- 表达式括号匹配、运算符求值、逆波兰计算
- 函数调用与递归的活动记录（调用栈）
- 深度优先搜索与回溯

学习目标：
1) 理解 LIFO 规则与栈顶/栈底的角色
2) 掌握基本操作的语义与时间开销
3) 能判断何时用栈建模问题，并与队列/数组等结构区分
4) 了解顺序栈与链式栈的差异（容量、扩容、内存分配）

栈的核心价值在于用简单的约束换取更清晰的过程控制和高效的常数级操作，是许多算法与系统机制（如编译器、操作系统）的基础。

## 2. 核心原理解释
栈的核心是“后进先出”（LIFO）：只允许在一端（栈顶）进行插入与删除。可用一个顺序表和栈顶指针 t 表示，初始 t = -1。

- 入栈 push：将元素写到 data[++t]，栈顶上移
- 出栈 pop：仅移动 t--，元素视为被移除
- 取顶 top：读取 data[t]，不修改 t
- 判空/判满：t == -1 或 t == 容量 - 1

由于只在栈顶操作，上述操作时间复杂度均为 O(1)。当 t 越界会产生上溢/下溢，需要在操作前检查边界。实现上既可用数组（连续内存、缓存友好），也可用链表（动态扩容、略有指针开销）。下面以动态数组示例展示 LIFO 行为。

```cpp
struct Stack {
    std::vector<int> a;
    void push(int x) { a.push_back(x); }
    void pop() { if (!a.empty()) a.pop_back(); }
    int top() const { return a.back(); }
    bool empty() const { return a.empty(); }
};

int main() {
    Stack s;
    s.push(1);
    s.push(2);
    std::cout << s.top() << "\n"; // 2
    s.pop();
    std::cout << s.top() << "\n"; // 1
}
```

## 3. 详细的实现步骤
1. 明确接口：需支持 push(x)、pop()、top()、empty()、size()；示例以 int 为元素类型。
2. 选型与原则：采用顺序栈（动态数组）实现，栈顶位于末尾，符合“后进先出”。该实现缓存友好，插入/删除均摊 O(1)。
3. 数据结构设计：内部以 std::vector<int> 保存数据，避免手写内存管理；对空栈操作应有明确行为。
4. 实现核心操作：
   - push：在末尾插入元素。
   - pop：检查空栈，取末尾元素后删除并返回。
   - top：检查空栈，读取末尾但不删除。
   - empty/size：查询状态。
5. 边界与异常：对空栈调用 pop/top 抛出 std::out_of_range，便于调用方捕获。
6. 自测与验证：压入若干值，检查 top 与弹出顺序是否为后进先出；同时验证空栈异常路径。
7. 复杂度与空间：各操作均摊 O(1)，空间随元素线性增长；异常路径 O(1)。

```cpp
#include <vector>
#include <stdexcept>
#include <iostream>

class Stack {
public:
    void push(int x) {
        data_.push_back(x);
    }
    int pop() {
        if (data_.empty()) throw std::out_of_range("stack is empty");
        int x = data_.back();
        data_.pop_back();
        return x;
    }
    int top() const {
        if (data_.empty()) throw std::out_of_range("stack is empty");
        return data_.back();
    }
    bool empty() const { return data_.empty(); }
    std::size_t size() const { return data_.size(); }
private:
    std::vector<int> data_;
};

int main() {
    Stack s;
    s.push(1);
    s.push(2);
    std::cout << s.top() << "\n";  // 2
    std::cout << s.pop() << "\n";  // 2
    std::cout << s.size() << "\n"; // 1
    return 0;
}
```

## 4. 完整的C++代码示例（包含注释）

## 5. 代码解析和说明
```cpp
#include <vector>
#include <stdexcept>

class Stack {
    std::vector<int> data;
public:
    void push(int x) { data.push_back(x); }
    void pop() {
        if (data.empty()) throw std::runtime_error("empty stack");
        data.pop_back();
    }
    int top() const {
        if (data.empty()) throw std::runtime_error("empty stack");
        return data.back();
    }
    bool empty() const { return data.empty(); }
    size_t size() const { return data.size(); }
};
```
代码说明：使用 std::vector 作为顺序存储容器，push 将元素追加到尾部（即栈顶）；pop 先判空避免下溢，再从尾部弹出；top 同样判空并读取尾元素；empty/size 为只读查询。top 标记为 const，保证可在常量对象上调用；接口最小化，仅暴露 LIFO 语义。异常策略采用抛出而非返回哨兵值，避免误判；资源由 vector 自动管理，无内存泄漏。

复杂度：均摊意义下，push/pop/top 均为 O(1)，empty/size 为 O(1)。当 vector 触发扩容时，单次 push 可能退化为 O(n)，但总体仍保持摊还 O(1)。空间复杂度为 O(n)。

边界与注意：
1) 空栈调用 pop/top 会抛出 runtime_error，调用方应捕获或先检查 empty。
2) 大量 push 前可在构造中调用 reserve(cap) 以减少扩容抖动与拷贝成本。
3) 非线程安全，多线程场景需外部同步。
4) 若承载大对象，可将 top 改为返回 const T& 并将类模板化 Stack<T>，以避免不必要拷贝（需保证引用有效）。

## 6. 使用场景和应用

栈是后进先出（LIFO）的线性结构，适合“最近的事先处理”的问题。常见应用包括：
- 函数调用与递归回溯：调用栈保存返回地址与局部变量，支持异常展开与调试。
- 表达式求值与括号匹配：中缀转后缀、逆波兰式计算、括号合法性检查。
- 撤销/重做与浏览器前进后退：操作历史用两个栈实现。
- 深度优先搜索（DFS）：显式栈替代递归控制搜索顺序。
- 语法解析与编译器：状态、符号处理的阶段性保存与恢复。
- 单调栈：求下一个更大/更小元素、直方图最大矩形等线性时间优化。

优势：
- 接口与实现简单，push/pop 均为 O(1)，常数开销小。
- 数据局部性好，缓存友好，易于在数组上实现。
- 与递归天然映射，逻辑直观。

劣势：
- 只能 LIFO，难以随机访问或中间插入删除。
- 容量受限（尤其系统调用栈），深递归易栈溢出。
- 多线程共享需同步，可能产生争用。

替代方案与比较：
- 队列/双端队列：需要 FIFO 或两端操作优先时更合适。
- 链表/动态数组：需要中间插入或按索引访问时优于栈。
- 优先队列/堆：按优先级调度而非时间顺序时选择堆。
- 递归 vs 显式栈：递归可读性好但深度受限；显式栈更可控、易避免溢出。

## 7. 注意事项和最佳实践

- 常见坑
  - 未检查是否为空就调用 top()/pop()，引发未定义行为或异常。
  - 固定容量（数组）实现缺少边界检查，导致上溢/下溢。
  - 将摊还 O(1) 误当作严格 O(1)，忽略扩容带来的性能抖动与迭代器失效。
  - 递归深度过大导致调用栈溢出，与数据栈容量无关，易被混淆。
  - 并发访问未加同步，出现数据竞争与破坏不变式。
  - 在 C++ 中误用 std::stack：pop 不返回值，应先 top 再 pop。

- 优化建议
  - 基于 vector 的实现提前 reserve 合理容量，或选用 deque 降低搬移成本。
  - 设计 API 时分离 peek 与 pop，返回引用以减少拷贝，异常安全更清晰。
  - 元素较大时优先 emplace/move，或改存指针/索引以减小栈内对象体积。
  - 深度可控场景使用静态数组/内存池，避免频繁分配；深递归改迭代。
  - 明确所有权与生命周期，避免悬垂引用；必要时添加最大深度保护。

- 测试要点
  - 边界用例：空栈、单元素、（固定容量）满载、连续 pop 到空。
  - 序列检验：顺序与随机 push/pop 与参考实现对拍，验证严格 LIFO。
  - 压测：长序列操作统计扩容次数与峰值内存，观察性能抖动。
  - 异常与中断：在抛异常/早返回后栈不变式（大小、顺序）仍成立。
  - 并发：多线程读写下正确性与性能，配合竞态检测工具验证无数据竞争。

## 8. 相关知识点与延伸阅读
- 相关概念
  - 队列、双端队列、优先队列：与栈对比理解先进先出、两端操作与取极值。
  - 数组与链表：栈的常见底层；std::stack 默认基于 deque，可替换为 vector/list。
  - 调用栈与递归：函数栈帧、栈溢出、尾递归优化；调试中的回溯（gdb/lldb）。
  - 典型应用：括号匹配、表达式求值、单调栈解决范围最大/次大、直方图面积等。
- 进阶方向
  - 算法：单调栈将问题降到 O(n)、在线处理、与滑动窗口/双指针组合。
  - 工程：异常安全与 RAII、并发/无锁栈（ABA 问题与内存回收）、缓存友好与内存池。
  - 泛型与适配器：自定义底层容器与迭代器设计，衡量时间/空间权衡。
- 参考资料
  - C++ Reference：std::stack；Cppreference 文档
  - 《算法导论》《算法（第4版）》栈与其应用
  - CSAPP：栈帧与调用约定；编译原理教材（递归下降）
  - MIT 6.006/6.046 讲义、LeetCode 栈专题题单
