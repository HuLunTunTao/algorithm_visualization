# 队列

## 1. 概念介绍和定义
队列（Queue）是一种遵循“先进先出”（FIFO）的线性数据结构，可以把它想象成现实中的排队买票：先到的人先被服务。一个队列通常维护两个端点：队头（front）用于取出元素，队尾（rear）用于加入元素。核心操作包括：入队（enqueue）、出队（dequeue）、查看队头元素（peek）、判断是否为空与获取长度。在合理实现下，这些操作通常可在 O(1) 时间内完成。常见实现有基于数组的循环队列、基于链表的链式队列，或直接使用语言提供的双端队列结构。

适用场景：
- 任务调度与缓冲：如打印队列、网络数据包缓冲，按到达顺序处理请求
- 图算法中的广度优先搜索：逐层扩展节点，保证最短步数遍历
- 生产者-消费者模型与消息队列：解耦上下游，平衡吞吐
- 限流与公平性控制：保障处理顺序与稳定性，避免饿死与乱序

学习目标：
1) 掌握队列的FIFO特性与基本术语（队头、队尾）
2) 理解核心操作与时间复杂度，并知道为何要用循环数组
3) 了解典型应用场景，明白队列在“顺序保真、吞吐稳定、解耦缓冲”方面的价值

## 2. 核心原理解释

队列的核心是先进先出（FIFO）：最先进入的元素最先被取出。关键在于用两个位置指示器维护“队头”和“队尾”，并保证入队只发生在尾、出队只发生在头，从而实现有序排队。常见有两类实现：环形数组（顺序存储）与单向链表（链式存储）。

- 环形数组的关键思想
  - 使用 head 指向队头元素，tail 指向下一个可写入位置，通过取模实现环绕：index = (index + 1) % cap。
  - 判空与判满可用两种策略：
    1) 维护 size：空为 size==0，满为 size==cap；
    2) 牺牲一格空间：空为 head==tail，满为 (tail+1)%cap==head。
  - 入队：写入 a[tail]，移动 tail；出队：读取 a[head]，移动 head。时间复杂度均为 O(1)，缓存友好。

- 链式队列的关键思想
  - 维护 head 指向首节点、tail 指向末节点。
  - 入队：在 tail 后追加新节点并移动 tail；出队：移除 head 并移动 head；当出队成空时需同步置空 tail。支持按需扩展，避免容量上限，但有分配开销与较弱的缓存局部性。

- 简单示例（环形数组）
  - 容量 cap=5，初始 head=0, tail=0（牺牲一格法）。
  - 入队 1,2,3：head=0, tail=3，逻辑顺序为 1,2,3。
  - 出队一次：head=1，逻辑顺序为 2,3。
  - 再入队 4,5：tail 依次变为 4、0（发生回绕），逻辑顺序从 head 开始：2,3,4,5。
  - 再入队将触发满条件 (tail+1)%cap==head，需要扩容或拒绝。

总结：环形数组在固定容量、追求高吞吐时更高效；链式队列适合元素数量不确定、需要弹性增长的场景。两者都通过“只在一端入、另一端出”的约束实现 FIFO。

## 3. 详细的实现步骤
- 明确需求：支持入队、出队、查看队首、判空/判满，操作均摊 O(1)。
- 选型：用循环数组实现（环形队列），避免线性搬移。
- 设计状态：数组 a、容量 n、头指针 h、尾指针 t、元素数 s；索引更新用取模运算。
- 入队：若满返回 false；写入 a[t]，t=(t+1)%n，s++。
- 出队：若空返回 false；h=(h+1)%n，s--。
- 取队首：若空按约定处理（返回值/异常）；返回 a[h]。对外提供 empty/full 便于调用前检查，统一错误处理策略。

```cpp
#include <vector>
using namespace std;

struct Q {
    vector<int> a; int n, h = 0, t = 0, s = 0;
    explicit Q(int cap) : a(cap), n(cap) {}
    bool en(int x) { if (s == n) return false; a[t] = x; t = (t + 1) % n; s++; return true; }
    bool de()      { if (!s) return false;      h = (h + 1) % n; s--; return true; }
    int  fr() const{ return a[h]; }
    bool emp()const{ return s == 0; }
    bool ful()const{ return s == n; }
};
```

## 4. 完整的C++代码示例（包含注释）

下面给出一个可编译运行的 C++17 示例，使用标准库 std::queue 演示队列的常见操作，并包含一个经典的队列应用：约瑟夫问题（Josephus）。程序通过命令驱动的方式从标准输入读取指令，输出相应结果。

支持的命令如下：
- push x：将整数 x 入队
- pop：队首元素出队并打印
- front：查看队首元素
- size：查看队列长度
- empty：判断队列是否为空
- print：从队首到队尾打印队列内容（不修改队列）
- clear：清空队列
- josephus n k：用队列模拟约瑟夫问题，打印出圈顺序和幸存者
- end：结束程序

```cpp
#include <iostream>
#include <queue>
#include <string>
#include <sstream>
#include <vector>

/*
  教学要点：
  1) 队列（queue）是先进先出（FIFO）的线性数据结构。
  2) 常用操作：
     - push(x)  入队：均摊/平均 O(1)
     - pop()    出队：O(1)
     - front()  取队首：O(1)
     - empty()  判空：O(1)
     - size()   长度：O(1)
  3) 迭代访问：std::queue 不支持直接迭代，如需打印元素，可

## 5. 代码解析和说明
```cpp
#include <vector>
#include <stdexcept>

class Queue {
    std::vector<int> buf;
    int head, tail, cnt;
public:
    explicit Queue(int cap): buf(cap), head(0), tail(0), cnt(0) {
        if (cap <= 0) throw std::invalid_argument("cap");
    }
    bool empty() const { return cnt == 0; }
    bool full() const { return cnt == (int)buf.size(); }
    void push(int x) {
        if (full()) throw std::runtime_error("full");
        buf[tail] = x;
        tail = (tail + 1) % buf.size();
        ++cnt;
    }
    void pop() {
        if (empty()) throw std::runtime_error("empty");
        head = (head + 1) % buf.size();
        --cnt;
    }
    int front() const {
        if (empty()) throw std::runtime_error("empty");
        return buf[head];
    }
    int size() const { return cnt; }
};
```
该实现使用循环数组构建定长队列：head指向队首元素，tail指向下一个可写位置，cnt记录当前元素数，既避免了“head==tail时的歧义，又便于O(1)获取size。

- 构造与成员：初始化缓冲区与指针，cap<=0时立即抛出非法参数，避免取模除零。
- 判空判满：通过cnt与容量比较，语义直观。
- push：满则抛错；写入tail后tail前进并取模，实现环绕；元素数自增。
- pop：空则抛错；head前进并取模；元素数自减。
- front：空则抛错；直接返回buf[head]；size返回cnt。

复杂度分析：
- 时间复杂度：push、pop、front、empty、size均为O(1)。
- 空间复杂度：O(capacity)。

边界与注意事项：
- 环绕场景（tail或head到达末端）通过取模保证正确性。
- 满或空时操作抛异常，可按需改为返回状态码以避免异常开销。
- 容量固定，如需自动扩容应在满时新建更大缓冲区并按顺序搬移元素。

## 6. 使用场景和应用
常见应用场景：
- 任务调度与生产者-消费者：线程池/作业队列缓冲突发流量，提升吞吐与解耦。
- 广度优先搜索：按层遍历图/树，保证最短步数优先。
- 消息队列与异步日志：解耦服务与写盘/网络，降低请求时延。
- 网络与IO缓冲：请求/包排队，平滑吞吐并吸收抖动。
- 限流与漏桶/令牌桶：控制速率、实现背压与削峰填谷。
- 操作系统就绪队列：进程/线程调度的基础结构。

优劣与权衡：
- 优点：FIFO公平、实现简单、支持异步解耦与削峰、便于扩展监控。
- 缺点：排队导致尾部延迟，无法表达优先级和依赖；长时间堆积引发超时/过期；需配合背压、丢弃策略与容量控制。

替代方案比较：
- 需要优先处理时用优先队列；两端插取与批量拼接选双端队列/环形缓冲；需要回溯/最近优先用栈；按主题广播与多订阅者选发布订阅/事件流；跨进程可靠传递用消息中间件；强并发隔离考虑Actor模型或通道（Channel）。

## 7. 注意事项和最佳实践
- 常见坑
  - 未判空直接调用 front/pop 导致未定义行为。
  - 误以为 std::queue 线程安全；跨线程访问需配合互斥锁与条件变量。
  - 队列无上限，在无背压时内存暴涨；应设容量与丢弃/阻塞策略。
  - 选错底层容器：用 vector 做队列会频繁搬移，优先 deque 或环形缓冲。
  - 在队列中存放指向短生命周期对象的指针/引用，造成悬挂引用。
- 优化建议
  - 明确容量与策略（阻塞、丢弃最旧/最新、降速），避免级联拥塞。
  - 对大对象使用 emplace 与 move，降低拷贝与分配开销。
  - 固定容量场景用环形缓冲或对象池，提高局部性与稳定性。
  - 批量 push/pop 降低锁竞争；用条件变量避免忙等和自旋。
  - 有严格顺序需求时避免多队列分片造成重排，必要时加序号重组。
- 测试要点
  - 边界：空、满、容量变化、下标回绕（环形缓冲）。
  - 顺序：严格 FIFO 与稳定性验证。
  - 并发压力：多生产者/消费者下的吞吐、尾延迟、死锁与丢/重问题。
  - 资源：内存上界、分配频率、缓存命中与抖动。
  - 异常与恢复：构造/移动抛异常场景处理；阻塞队列的超时与伪唤醒。

```cpp
#include <queue>
#include <string>

std::queue<std::string> q;
// 安全弹出：先判空，再移动取出，最后弹出
if (!q.empty()) {
    std::string v = std::move(q.front());
    q.pop();
}
// 优化入队：原地构造，避免中间拷贝
q.emplace(3, 'x'); // 生成 "xxx"
```

## 8. 相关知识点与延伸阅读
- 相关概念：栈 vs 队列；双端队列 deque、循环队列、优先队列；单调队列（滑动窗口优化）；阻塞队列、并发/无锁队列、SPSC/MPSC；消息队列（Kafka/RabbitMQ）、任务队列、BFS。
- 进阶方向：复杂度与容量扩缩；缓存局部性与假共享；内存模型、CAS 与 ABA；无锁队列的内存回收（Hazard Pointer/Epoch）；背压与限流；实时性与吞吐权衡；基准测试与可观测性。
- 参考资料：CLRS 队列与 BFS 章节；cppreference：std::queue/std::deque/std::priority_queue；Michael & Scott 无锁队列论文；Boost.Lockfree queue；Herb Sutter 并发系列；Kafka/RabbitMQ 文档中的队列语义与背压实践。
