# 优先队列

## 1. 概念介绍和定义

优先队列是一种特殊的队列数据结构，其中每个元素都关联有一个“优先级”。与普通队列遵循先进先出（FIFO）规则不同，优先队列中的元素按照优先级顺序出队：优先级最高的元素最先被移除，而不管它何时加入队列。

优先队列的核心操作包括：
- 插入（enqueue）：向队列中添加一个带有优先级的元素
- 删除最高优先级元素（dequeue）：移除并返回优先级最高的元素
- 查看最高优先级元素（peek）：返回但不移除优先级最高的元素

适用场景：
- 任务调度系统：高优先级任务优先执行
- 网络数据包传输：紧急数据优先发送
- 算法应用：Dijkstra最短路径算法、哈夫曼编码等
- 事件驱动模拟：按时间顺序处理事件

目标：提供高效的元素管理方式，确保最高优先级的元素能够快速被访问和处理，同时保持合理的插入和删除性能。

```cpp
#include <queue>
#include <iostream>
using namespace std;

int main() {
    // 创建一个最大堆优先队列（默认）
    priority_queue<int> pq;
    
    // 插入元素
    pq.push(30);
    pq.push(10);
    pq.push(20);
    
    // 访问和删除最高优先级元素
    cout << "最高优先级元素: " << pq.top() << endl;
    pq.pop();
    cout << "下一个最高优先级元素: " << pq.top() << endl;
    
    return 0;
}
```

## 2. 核心原理解释

优先队列的核心原理基于二叉堆（Binary Heap）数据结构实现，通常使用数组来存储元素。其关键思想是维护一个满足堆性质的完全二叉树，确保每个节点的值都大于或等于（最大堆）或小于或等于（最小堆）其子节点的值。这种结构使得优先级最高的元素始终位于堆顶，从而实现高效的元素访问和操作。

### 关键操作原理
优先队列主要支持以下核心操作，每个操作的时间复杂度均为 O(log n)：

- **插入（Push）**：将新元素添加到堆的末尾，然后通过“上浮”（Heapify Up）操作调整其位置，直到堆性质恢复。
- **弹出（Pop）**：移除堆顶元素（最高优先级），将末尾元素移至堆顶，然后通过“下沉”（Heapify Down）操作调整其位置，直到堆性质恢复。
- **查看堆顶（Top）**：直接返回堆顶元素，时间复杂度为 O(1)。

### 简单示例说明
假设我们有一个最小堆（优先级由小到大），初始堆为 [1, 3, 2, 6, 4, 5]。其结构如下所示（括号内为数组索引）：
```
        1(0)
      /      \
    3(1)      2(2)
   /   \      / 
 6(3) 4(4)  5(5)
```

**插入操作示例**：插入元素 0
1. 将 0 添加到末尾，数组变为 [1, 3, 2, 6, 4, 5, 0]
2. 比较 0 与其父节点（索引 2：(2-1)/2=1）的值 2，由于 0 < 2，交换位置
3. 继续比较 0 与新的父节点（索引 1：(1-1)/2=0）的值 1，由于 0 < 1，交换位置
4. 0 到达根节点，调整结束。最终堆为 [0, 1, 2, 6, 3, 5, 4]

**弹出操作示例**：弹出堆顶元素 0
1. 将堆顶元素 0 与末尾元素 4 交换，数组变为 [4, 1, 2, 6, 3, 5, 0]
2. 移除末尾元素 0，堆变为 [4, 1, 2, 6, 3, 5]
3. 从根节点 4 开始，与其子节点（左：1，右：2）比较，选择较小的子节点 1
4. 由于 4 > 1，交换位置，数组变为 [1, 4, 2, 6, 3, 5]
5. 继续比较 4 与其新的子节点（左：3，右：5），选择较小的 3
6. 由于 4 > 3，交换位置，调整结束。最终堆为 [1, 3, 2, 6, 4, 5]

### 代码实现关键
以下是最小堆的核心操作代码片段：

```cpp
// 上浮操作
void heapifyUp(int index) {
    while (index > 0) {
        int parent = (index - 1) / 2;
        if (heap[parent] <= heap[index]) break;
        swap(heap[parent], heap[index]);
        index = parent;
    }
}

// 下沉操作
void heapifyDown(int index) {
    int left = 2 * index + 1;
    while (left < heap.size()) {
        int right = left + 1;
        int smaller = left;
        if (right < heap.size() && heap[right] < heap[left]) {
            smaller = right;
        }
        if (heap[index] <= heap[smaller]) break;
        swap(heap[index], heap[smaller]);
        index = smaller;
        left = 2 * index + 1;
    }
}
```

通过这种结构，优先队列在插入和删除时都能保持 O(log n) 的高效性能，同时保证最高优先级的元素始终可快速访问。

## 3. 详细的实现步骤

实现优先队列通常基于二叉堆结构，以下是使用数组存储的最小堆实现步骤：

1. **定义数据结构与初始化**
   - 使用动态数组存储堆元素
   - 记录当前堆的大小和容量

```cpp
#include <vector>
#include <algorithm>

class MinHeap {
private:
    std::vector<int> heap;
    int capacity;
    int size;
    
public:
    MinHeap(int capacity) : capacity(capacity), size(0) {
        heap.resize(capacity);
    }
};
```

2. **实现核心辅助方法**
   - 获取父节点、左子节点、右子节点索引
   - 上浮(heapifyUp)和下沉(heapifyDown)操作

```cpp
int parent(int i) { return (i - 1) / 2; }
int left(int i) { return 2 * i + 1; }
int right(int i) { return 2 * i + 2; }

void heapifyUp(int i) {
    while (i > 0 && heap[parent(i)] > heap[i]) {
        std::swap(heap[i], heap[parent(i)]);
        i = parent(i);
    }
}

void heapifyDown(int i) {
    int minIndex = i;
    int l = left(i);
    int r = right(i);
    
    if (l < size && heap[l] < heap[minIndex])
        minIndex = l;
    if (r < size && heap[r] < heap[minIndex])
        minIndex = r;
    
    if (i != minIndex) {
        std::swap(heap[i], heap[minIndex]);
        heapifyDown(minIndex);
    }
}
```

3. **实现主要操作接口**
   - 插入元素：添加到末尾并上浮
   - 提取最小元素：交换首尾元素后下沉
   - 查看最小元素：返回堆顶元素

```cpp
void insert(int key) {
    if (size == capacity) {
        // 可在此处实现扩容
        return;
    }
    heap[size] = key;
    heapifyUp(size);
    size++;
}

int extractMin() {
    if (size == 0) return -1;
    
    int min = heap[0];
    heap[0] = heap[size - 1];
    size--;
    heapifyDown(0);
    return min;
}

int getMin() {
    return size > 0 ? heap[0] : -1;
}
```

实现要点：
- 始终保持堆的性质：父节点值小于等于子节点值
- 插入操作时间复杂度为 O(log n)
- 提取最小元素时间复杂度为 O(log n)
- 动态数组需要处理扩容情况（示例中未展示）

## 4. 完整的C++代码示例（包含注释）

以下是一个使用C++17标准实现的优先队列完整示例代码。该示例展示了如何创建最大堆和最小堆，以及如何进行基本操作。

```cpp
#include <iostream>
#include <queue>        // 包含priority_queue
#include <vector>       // 包含vector
#include <functional>   // 包含greater

using namespace std;

int main() {
    // 示例1：创建最大堆（默认）
    cout << "=== 最大堆示例 ===" << endl;
    priority_queue<int> maxHeap;
    
    // 向堆中插入元素
    maxHeap.push(30);
    maxHeap.push(10);
    maxHeap.push(50);
    maxHeap.push(20);
    maxHeap.push(40);
    
    cout << "最大堆元素（从大到小弹出）: ";
    while (!maxHeap.empty()) {
        // 访问堆顶元素（当前最大值）
        cout << maxHeap.top() << " ";
        
        // 弹出堆顶元素
        maxHeap.pop();
    }
    cout << endl << endl;
    
    // 示例2：创建最小堆
    cout << "=== 最小堆示例 ===" << endl;
    // 使用greater<int>作为比较函数，创建最小堆
    priority_queue<int, vector<int>, greater<int>> minHeap;
    
    // 向堆中插入相同的元素
    minHeap.push(30);
    minHeap.push(10);
    minHeap.push(50);
    minHeap.push(20);
    minHeap.push(40);
    
    cout << "最小堆元素（从小到大弹出）: ";
    while (!minHeap.empty()) {
        // 访问堆顶元素（当前最小值）
        cout << minHeap.top() << " ";
        
        // 弹出堆顶元素
        minHeap.pop();
    }
    cout << endl << endl;
    
    // 示例3：使用自定义比较函数
    cout << "=== 自定义比较函数示例 ===" << endl;
    
    // 自定义比较函数：按数字的绝对值大小比较
    auto absCompare = [](int a, int b) {
        return abs(a) < abs(b); // 绝对值大的优先级高
    };
    
    // 使用decltype推导lambda类型，需要指定容器类型
    priority_queue<int, vector<int>, decltype(absCompare)> customHeap(absCompare);
    
    // 插入正负数混合的元素
    customHeap.push(-30);
    customHeap.push(10);
    customHeap.push(-50);
    customHeap.push(20);
    customHeap.push(40);
    
    cout << "按绝对值大小弹出的顺序: ";
    while (!customHeap.empty()) {
        cout << customHeap.top() << " ";
        customHeap.pop();
    }
    cout << endl;
    
    return 0;
}
```

**代码说明：**

- **头文件包含**：
  - `<queue>`：提供priority_queue容器
  - `<vector>`：作为priority_queue的底层容器
  - `<functional>`：提供greater等函数对象

- **三种优先队列创建方式**：
  1. 默认最大堆：`priority_queue<int>`
  2. 最小堆：`priority_queue<int, vector<int>, greater<int>>`
  3. 自定义比较函数：使用lambda表达式和decltype

- **主要操作**：
  - `push()`：插入元素
  - `top()`：访问堆顶元素
  - `pop()`：弹出堆顶元素
  - `empty()`：检查队列是否为空

**运行结果：**
```
=== 最大堆示例 ===
最大堆元素（从大到小弹出）: 50 40 30 20 10 

=== 最小堆示例 ===
最小堆元素（从小到大弹出）: 10 20 30 40 50 

=== 自定义比较函数示例 ===
按绝对值大小弹出的顺序: -50 40 -30 20 10 
```

## 5. 代码解析和说明

以下是一个使用C++标准库priority_queue实现最小堆的完整示例代码：

```cpp
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

int main() {
    // 创建最小优先队列
    priority_queue<int, vector<int>, greater<int>> minHeap;
    
    // 插入元素
    minHeap.push(3);
    minHeap.push(1);
    minHeap.push(4);
    minHeap.push(2);
    
    cout << "堆顶元素（最小值）: " << minHeap.top() << endl;
    
    // 弹出并输出所有元素
    cout << "按升序输出元素: ";
    while (!minHeap.empty()) {
        cout << minHeap.top() << " ";
        minHeap.pop();
    }
    cout << endl;
    
    return 0;
}
```

**代码解析**：
- 第7行使用模板参数`greater<int>`创建最小堆，默认是最大堆（使用`less<int>`）
- `push()`操作将元素插入堆中并维护堆结构
- `top()`返回堆顶元素（最小值）但不移除
- `pop()`移除堆顶元素并重新调整堆结构
- `empty()`检查队列是否为空

**时间复杂度分析**：
- 插入操作（push）：O(log n)，需要上浮调整
- 删除操作（pop）：O(log n)，需要下沉调整
- 获取堆顶（top）：O(1)，直接访问根节点
- 总体空间复杂度：O(n)，存储所有元素

**边界情况处理**：
- 空队列访问top()或pop()会导致未定义行为，必须先检查empty()
- 大量数据插入时需要考虑内存限制
- 自定义比较器时需要确保严格弱序关系
- 多线程环境下需要额外的同步机制

## 6. 使用场景和应用

优先队列在多种场景下发挥着重要作用，特别适合需要动态获取最高或最低优先级元素的场合。以下是几个典型应用场景：

- **任务调度系统**：操作系统使用优先队列管理进程，高优先级任务优先执行
- **Dijkstra 算法**：在图的最短路径算法中，优先队列用于高效获取当前最短路径节点
- **数据流的中位数查找**：通过维护两个优先队列（最大堆和最小堆）实时计算中位数
- **哈夫曼编码**：在构建最优前缀码时，优先队列用于高效合并频率最低的节点

**优劣分析**：
优先队列的主要优势在于能快速访问和删除最高/最低优先级元素（O(1)时间复杂度），插入操作也相对高效（O(log n)）。然而，它不适合需要随机访问或查找特定元素的场景，这些操作的时间复杂度较高（O(n)）。

**替代方案比较**：
- **有序数组/链表**：查找最值快但插入慢（O(n)），适合静态数据
- **平衡二叉搜索树**：支持更多操作但实现复杂，内存开销较大
- **跳表**：提供类似性能但实现相对简单，适合并发环境

```cpp
// 使用优先队列实现任务调度示例
#include <queue>
#include <vector>
#include <iostream>
using namespace std;

struct Task {
    int priority;
    string name;
    
    // 重载运算符定义优先级比较
    bool operator<(const Task& other) const {
        return priority < other.priority; // 值越大优先级越高
    }
};

int main() {
    priority_queue<Task> scheduler;
    
    // 添加任务
    scheduler.push({3, "系统监控"});
    scheduler.push({1, "数据备份"});
    scheduler.push({5, "用户请求"});
    
    // 按优先级执行任务
    while (!scheduler.empty()) {
        Task task = scheduler.top();
        cout << "执行任务: " << task.name << endl;
        scheduler.pop();
    }
    
    return 0;
}
```

在实际选择时，应根据具体需求权衡：如果需要频繁获取最值且数据动态变化，优先队列是最佳选择；如果需要支持更多查询操作，则可以考虑平衡二叉搜索树等替代方案。

## 7. 注意事项和最佳实践

在使用优先队列时，需要注意以下几个常见问题、优化建议和测试要点，以确保代码的正确性和高效性。

### 常见坑
- **自定义比较函数错误**：在使用自定义比较器时，容易混淆最大堆和最小堆的逻辑。记住，默认的 `std::less` 生成的是最大堆，而 `std::greater` 生成的是最小堆。
- **迭代器失效**：优先队列不支持随机访问或遍历修改，强行操作可能导致未定义行为。
- **对象生命周期管理**：如果存储指针，需自行管理内存，避免悬垂指针或内存泄漏。

### 优化建议
- **预留容量**：如果事先知道元素数量，可使用 `reserve` 方法（如果底层容器支持）减少动态扩容的开销。
- **使用 emplace**：对于复杂对象，使用 `emplace` 避免不必要的拷贝或移动操作。
- **选择底层容器**：默认使用 `vector`，但在频繁插入删除且数据量极大时，可考虑 `deque` 作为替代以优化性能。

### 测试要点
- 验证队列是否始终保持堆性质，特别是在多次插入和删除后。
- 测试边界情况，如空队列时的 `top()` 或 `pop()` 操作。
- 对于自定义类型，确保比较逻辑严格弱序，避免运行时错误。

示例代码：使用自定义比较函数

```cpp
#include <queue>
#include <vector>
#include <iostream>

struct Task {
    int priority;
    std::string name;
    
    // 自定义比较函数，优先级数值小的优先
    bool operator>(const Task& other) const {
        return priority > other.priority;
    }
};

int main() {
    // 最小堆，优先级小的先出队
    std::priority_queue<Task, std::vector<Task>, std::greater<Task>> pq;
    
    pq.push({3, "Low priority task"});
    pq.push({1, "High priority task"});
    pq.push({2, "Medium priority task"});
    
    while (!pq.empty()) {
        Task task = pq.top();
        std::cout << task.name << " (Priority: " << task.priority << ")\n";
        pq.pop();
    }
    
    return 0;
}
```

## 8. 相关知识点与延伸阅读

优先队列是数据结构与算法中的重要概念，掌握它后可以进一步了解以下相关内容：

### 相关概念
- **堆（Heap）**：优先队列通常基于堆实现，特别是二叉堆
- **完全二叉树**：堆的本质是一棵完全二叉树，具有高效的插入和删除特性
- **稳定性**：当优先级相同时，不同实现的优先队列可能有不同的元素处理顺序

### 进阶方向
1. **多种堆结构**：除了二叉堆，还可以学习二项堆、斐波那契堆等更高效的实现
2. **并发优先队列**：在多线程环境下如何安全地使用优先队列
3. **应用扩展**：探索在操作系统调度、网络路由算法等领域的实际应用

### 参考资料
- 《算法导论》第6章 - 堆排序
- 《数据结构与算法分析》第6章 - 优先队列
- 在线资源：GeeksforGeeks的"Binary Heap"专题
- 实践平台：LeetCode上相关题目（如第23题"合并K个升序链表"）

```cpp
// 示例：使用STL priority_queue实现最小堆
#include <queue>
#include <vector>
#include <iostream>
using namespace std;

int main() {
    // 创建最小堆
    priority_queue<int, vector<int>, greater<int>> minHeap;
    
    minHeap.push(3);
    minHeap.push(1);
    minHeap.push(4);
    
    while (!minHeap.empty()) {
        cout << minHeap.top() << " ";
        minHeap.pop();
    }
    // 输出：1 3 4
    return 0;
}
```
